#!/usr/bin/env python3
"""
Script to apply package updates from package_versions.json to the Bazel extension files.

This script reads the JSON file generated by update_packages.py and updates the
corresponding extension.bzl files with new package versions and SHA256 hashes.
"""

import json
import re
import sys
from pathlib import Path
from typing import Dict


def update_packages_in_bzl(
    bzl_file: Path, arch: str, packages: Dict[str, Dict[str, str]]
) -> tuple[bool, list[str]]:
    """
    Update package versions and SHA256 hashes in a Bazel extension file for a specific architecture.

    Returns (True, list of updated packages) if changes were made, (False, []) otherwise.
    """
    if not bzl_file.exists():
        print(f"Warning: {bzl_file} does not exist, skipping")
        return False, []

    content = bzl_file.read_text()

    # Find the architecture section in _PACKAGES_BY_ARCH
    # We need to find the arch block and match balanced braces
    # Start by finding the arch key
    arch_start_pattern = rf'"{re.escape(arch)}"\s*:\s*\{{'
    arch_start_match = re.search(arch_start_pattern, content)

    if not arch_start_match:
        print(f"    Warning: Could not find {arch} section in {bzl_file}")
        return False, []

    # Now find the matching closing brace by counting braces
    arch_section_start = arch_start_match.start()
    brace_count = 0
    in_arch_section = False
    arch_section_end = None

    for i in range(arch_start_match.end(), len(content)):
        if content[i] == "{":
            brace_count += 1
            in_arch_section = True
        elif content[i] == "}":
            if brace_count == 0 and in_arch_section:
                # This is the closing brace for the arch section
                arch_section_end = i + 1
                break
            brace_count -= 1

    if arch_section_end is None:
        print(
            f"    Warning: Could not find end of {arch} section in {bzl_file}"
        )
        return False, []

    arch_section_content = content[arch_section_start:arch_section_end]
    original_arch_section = arch_section_content
    updated_packages = []

    # For each package, find and update its version and sha256 within this architecture section
    for package_name, package_info in packages.items():
        version = package_info["version"]
        sha256 = package_info["sha256"]

        # Pattern to match the package block
        # Looking for: "package-name": { "version": "...", "sha256": "..." }
        package_pattern = rf'("{re.escape(package_name)}"\s*:\s*\{{[^}}]*"version"\s*:\s*")[^"]*(".*?"sha256"\s*:\s*")[^"]*(")'

        # Check if this package needs updating
        match = re.search(
            package_pattern, arch_section_content, flags=re.DOTALL
        )
        if match:
            # Extract current values to see if they're different
            current_block = match.group(0)

            def replacer(m):
                return f"{m.group(1)}{version}{m.group(2)}{sha256}{m.group(3)}"

            new_block = replacer(match)

            if current_block != new_block:
                updated_packages.append(package_name)
                arch_section_content = re.sub(
                    package_pattern,
                    replacer,
                    arch_section_content,
                    flags=re.DOTALL,
                )

    # Only update if changes were made to this architecture section
    if arch_section_content != original_arch_section:
        content = (
            content[:arch_section_start]
            + arch_section_content
            + content[arch_section_end:]
        )
        bzl_file.write_text(content)
        return True, updated_packages

    return False, []


def main():
    # Read the package versions JSON
    json_file = Path("package_versions.json")
    if not json_file.exists():
        print("Error: package_versions.json not found")
        print(
            "Run update_packages.py first to generate the package versions file"
        )
        sys.exit(1)

    with open(json_file) as f:
        package_data = json.load(f)

    print("Applying package updates from package_versions.json...\n")

    # Map distribution names to their extension files
    distro_mapping = {
        "fedora": ("fedora_gcc/extensions.bzl", ["x86_64", "aarch64"]),
        "autosd_10": ("autosd_10_gcc/extensions.bzl", ["x86_64", "aarch64"]),
        "autosd_9": ("autosd_9_gcc/extensions.bzl", ["x86_64", "aarch64"]),
    }

    changes_made = False

    for distro_name, (bzl_path, arches) in distro_mapping.items():
        if distro_name not in package_data:
            print(f"Warning: No package data found for {distro_name}")
            continue

        print(f"\nProcessing {distro_name}...")
        print(f"{'=' * 80}")

        bzl_file = Path(bzl_path)
        file_changed = False

        for arch in arches:
            if arch not in package_data[distro_name]:
                print(f"  Warning: No {arch} packages found for {distro_name}")
                continue

            packages = package_data[distro_name][arch]
            print(f"  Updating {arch} packages ({len(packages)} packages)...")

            changed, updated_pkgs = update_packages_in_bzl(
                bzl_file, arch, packages
            )
            if changed:
                file_changed = True
                print(
                    f"    ✓ Updated {len(updated_pkgs)} package(s): {', '.join(updated_pkgs)}"
                )
            else:
                print(f"    No changes needed for {arch}")

        if file_changed:
            changes_made = True
            print(f"  ✓ Updated {bzl_file}")

    print(f"\n{'=' * 80}")
    if changes_made:
        print("✓ Package updates applied successfully!")
        print("\nNext steps:")
        print("  1. Review the changes: git diff")
        print("  2. Test the builds: bazel test //...")
        print(
            "  3. Commit the changes: git commit -am 'Update package versions'"
        )
    else:
        print("  No changes were needed - all packages are already up to date")

    return 0 if changes_made else 1


if __name__ == "__main__":
    sys.exit(main())
